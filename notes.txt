demo4.js
执行结果：123
原因：
setTimeout()只是将事件插入了"任务队列"，
必须等到当前代码（执行栈）执行完，
主线程才会去执行它指定的回调函数。
process.nextTick()方法，
指定的任务总是发生在所有异步任务之前，当前主线程的末尾。


demo7.js
执行结果：
同步读取：XXX
程序执行完毕
异步读取：XXX
原因：
（1）所有同步任务都在主线程上执行，形成一个执行栈。
（2）主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。

callkack.js
1）执行结果：
feicuigood
2）执行结果：
0 1
原因：
只有事件发生的时候,才会调用回调函数

IO.js
1）执行结果:
XXX
程序执行结束

2）执行结果:
程序执行结束
XXX
原因：
阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，
是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，
而非阻塞方式下，读取或者写入函数会立即返回一个状态值。

